/** 
 * Copyright (c) 2012-2015 Advanced Numerics Advisors Michal Rewienski and
 * Mayukh Bhattacharya. All rights reserved.
 * CONFIDENTIAL - This is an unpublished proprietary work of Advanced
 * Numerics Advisors Michal Rewienski and Mayukh Bhattacharya, and is
 * fully protected under copyright and trade secret laws. You may not
 * view, use, disclose, copy, or distribute this file or any information
 * contained herein except pursuant to a valid written license from
 * Advanced Numerics Advisors Michal Rewienski and Mayukh Bhattacharya.
 */

#ifndef RANDGEN_H
#define RANDGEN_H
#include "porttype.h"

#define engineopt 1

/** Random number generator functions have this type */
typedef UINT32_t randfun_t(void);

/** This points to the selected random number generator function */
extern randfun_t * myrand;

/** This stores the vale of RAND_MAX for the currently used RNG (myrand points to it) */
extern UINT64_t MY_RAND_MAX;

/** This seeds and warms up a random number generator. */
void rng_init(UINT32_t rngtype);

/** JKISS pseudorandom number generator, returns a pseudorandom unsigned
    integer number */
UINT32_t JKISS(void);

/** JKISS pseudorandom number generator, returns a pseudorandom unsigned
    integer number */
UINT32_t JKISS32(void);

/** This seeds the JKISS/JKISS32 generators. For JKISS set w = 0, for JKISS32 set c = 0 */
void JKISS_seed(UINT32_t x, UINT32_t y, UINT32_t z, UINT32_t c, UINT32_t w);

/*
 * Initialize the default Mersenne Twist PRNG from a 32-bit seed.
 *
 * See mts_seed32new for full commentary.
 */
void mt_seed32new(UINT32_t seed);		/* 32-bit seed to start from */

/*
 * Initialize the PRNG from random input.  See mts_seed.
 */
UINT32_t mt_seed(void);

/**
 * The following value is a fundamental parameter of the algorithm.
 * It was found experimentally using methods described in Matsumoto
 * and Nishimura's paper.  It is exceedingly magic; don't change it.
 */
#define MT_STATE_SIZE	624		/* Size of the MT state vector */

/** In Matsumoto and Nishimura's original paper, the state vector was
 * processed in a forward direction.  I have reversed the state vector
 * in this implementation.  The reason for the reversal is that it
 * allows the critical path to use a test against zero instead of a
 * test against 624 to detect the need to refresh the state.  on most
 * machines, testing against zero is slightly faster.  It also means
 * that a state that has been set to all zeros will be correctly
 * detected as needing initialization; this means that setting a state
 * vector to zero (either with memset or by statically allocating it)
 * will cause the RNG to operate properly.
 */
typedef struct mt_state_t
    {
    UINT32_t statevec[MT_STATE_SIZE]; /* Vector holding current state */
    INT32_t  stateptr;	/* Next state entry to be used */
    INT32_t  initialized;	/* NZ if state was initialized */
    }
  mt_state;

/* Generate 624 more random values */
extern void mts_refresh(mt_state* state);

/*
 * Tempering parameters.  These are perhaps the most magic of all the magic
 * values in the algorithm.  The values are again experimentally determined.
 * The values generated by the recurrence relation (constants above) are not
 * equidistributed in 623-space.  For some reason, the tempering process
 * produces that effect.  Don't ask me why.  Read the paper if you can
 * understand the math.  Or just trust these magic numbers.
 */
#define MT_TEMPERING_MASK_B 0x9d2c5680
#define MT_TEMPERING_MASK_C 0xefc60000
#define MT_TEMPERING_SHIFT_U(y) \
			(y >> 11)
#define MT_TEMPERING_SHIFT_S(y) \
			(y << 7)
#define MT_TEMPERING_SHIFT_T(y) \
			(y << 15)
#define MT_TEMPERING_SHIFT_L(y) \
			(y >> 18)

/*
 * Macros to do the tempering.  MT_PRE_TEMPER does all but the last step;
 * it's useful for situations where the final step can be incorporated
 * into a return statement.  MT_FINAL_TEMPER does that final step (not as
 * an assignment).  MT_TEMPER does the entire process.  Note that
 * MT_PRE_TEMPER and MT_TEMPER both modify their arguments.
 */
#define MT_PRE_TEMPER(value)						\
    do									\
	{								\
	value ^= MT_TEMPERING_SHIFT_U(value);				\
	value ^= MT_TEMPERING_SHIFT_S(value) & MT_TEMPERING_MASK_B;	\
	value ^= MT_TEMPERING_SHIFT_T(value) & MT_TEMPERING_MASK_C;	\
	}								\
	while (0)
#define MT_FINAL_TEMPER(value) \
			((value) ^ MT_TEMPERING_SHIFT_L(value))


/*
 * The Mersenne Twist PRNG makes it default state available as an
 * external variable.  This feature is undocumented, but is useful to
 * use because it allows us to avoid implementing every randistr function
 * twice.  (In fact, the feature was added to enable randistrs.c to be
 * written.  It would be better to write in C++, where I could control
 * the access to the state.)
 */
extern mt_state		mt_default_state;
					/* State of the default generator */
/*
 * In gcc, inline functions must be declared extern or they'll produce
 * assembly code (and thus linking errors).  We have to work around
 * that difficulty with the MT_EXTERN define.
 */
#ifndef MT_EXTERN
#define MT_EXTERN	extern		/* C (at least gcc) needs extern */
#endif /* MT_EXTERN */


/*
 * Make it possible for mtwist.c to disable the inline keyword.  We
 * use our own keyword so that we don't interfere with inlining in
 * C/C++ header files, above.
 */
#ifndef MT_INLINE
#define MT_INLINE	inline		/* Compiler has inlining */
#endif /* MT_INLINE */


/*
 * Generate a random number in the range 0 to 2^32-1, inclusive, working
 * from the default state vector.
 *
 * See mts_lrand for full commentary.
 */
/*MT_EXTERN*/ MT_INLINE UINT32_t mt_lrand(void)//UWAGA, NIE WIADOMO CZY POD LINUKSEM NIE BEDZIE GENEROWALO KLOPOTOW
    {
    register UINT32_t	random_value;	/* Pseudorandom value generated */

    if (mt_default_state.stateptr <= 0)
	mts_refresh(&mt_default_state);

    random_value = mt_default_state.statevec[--mt_default_state.stateptr];
    MT_PRE_TEMPER(random_value);

    return MT_FINAL_TEMPER(random_value);
    }

#endif /* RANDGEN_H */
